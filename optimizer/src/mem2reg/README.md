## mem2reg

> 此 pass 需要 GVN 的结果

虽然编译器前端可以在不使用 load store 的情况下直接生成 ssa，但 mem2reg 方法仍然能用于消除内存访问与修改中的冗余。

此 pass 分为以下几个步骤：

1. 构建待修改变量表
2. 插入 phi 语句
3. 代码生成

一言蔽之，就是将每个被操作的地址都看成一个变量，然后做 mem2reg。

### 构建待修改变量表

利用 gvn 的结果，我们可以用将每个地址表示成 `(base, offset)` 的形式，`base` 不同的变量我们认为不会相交。根据前年的测例情况，在假定函数参数内的指针指向的空间不交不会导致错误产生。（真导致了内联一下应该也没了）

将 `(base, offset)` 称作 `Addr`，那么我们会认为函数中访问的所有 `Addr` 都对应了一个变量。

### 插入 phi 语句

先复习一下 mem2reg 中插入 phi 语句的过程，在此略去所有证明：

对于一个地址 $x$，找到所有写入 $x$ 的基本块，这些基本块构成集合 $def(x)$。那么 $def(x)$ 的**迭代支配边界**就是所有出现不同版本 $x$ 汇合的地方。定义 $DF(S)$ 表示 $S$ 中所有元素的支配边界的并集，则迭代支配边界是方程 $DF^{+}(S) = DF(S\cup DF^{+}(S))$ 的迭代不动点。然后在 $DF^{+}(S)$ 中每个块开头插入 phi 语句即可。

要在支持以变量下标访问数组的情况下支持 mem2reg 其实和上述过程大差不差，唯一的区别是 $def(x)$ 的计算会发生变化。

对于 Addr 对应的变量 $x$，所有存在修改 Addr 可能的指令都会定义一个新版本的 $x$ 出来，这些情况包括：

1. Store 指令操作的地址 Addr' 等于 Addr 或与 Addr 相差的不是常数。
2. Call 指令调用的函数会修改与该 Addr base 相等的位置。

称这些情况对 Addr 产生了“未可知修改”，那么对 Addr 产生未可知修改的块也都应当被算在 $def(x)$ 之中。

### 代码生成

原本的 load 语句和 store 语句并非都可以被删除，其中一部分仍然需要保留下来以处理未可知修改的情况。当然根据 pass 组合的设计思路，我们只需要删除那些其他 pass 删不掉的指令。

此外插入的 phi 语句也可能是不必要的，为了防止此 pass 与 无用代码消除 产生死循环，无用的 phi 语句也应当在此处被干掉。

在插入完 phi 语句之后，dfs 支配树，我们能计算每个基本块开头和结尾时的数组状态 ArrayState，即 Addr 到 Value 的映射关系。对于某个基本块 u，其开头处的 ArrayState 为其直接支配者出口处的 ArrayState 再加上新添加的 phi 语句定义的变量。

#### load 消除

如果一个 load 指令访问的地址在 ArrayState 中可以被查询到，那么这个 load 指令是冗余的，可以直接将 load 出的变量替换为 ArrayState 中查询到的结果；同时如果 load 出的结果是 phi 语句定义的，则将这条 phi 语句标记为 “实例化”。

#### store 消除

如果 store 语句的副作用是需要被使用的，则这条语句需要被保留。同时副作用被使用存在以下几种情况：

1. 保存的值被未可知修改覆盖掉。
2. 保存的值被标记为“被保存” 的 phi 语句作为操作数。
3. Call 指令调用的函数的参数中存在与 Store 语句的 Addr 有相同 base 的项。

特别的，如果一条 store 语句写入的值就等于当前位置的值，那么这条 store 语句应当无条件被删除。

#### phi 消除

在上面的过程中对 phi 指令产生了两种标记“实例化”和“被保存”，下面来进行处理。

##### 实例化

该变量需要出现在程序中，这里也分成两种情况：

1. 若该 phi 指令的操作数在其前驱中均未被实例化，则将 phi 指令替换为从对应位置 load。
2. 否则，在所有未被实例化的前驱中插入 load 指令实例化操作数。

其中情况 2 是为了消除 load 的部分冗余。

##### 被保存

该变量的副作用会被使用，这与 store 消除中的情况是相同的。我们将构建一个变量在 phi 语句中的使用情况，通过遍历的方式找出所有需要被保存的变量以及保存这些变量的语句，并完成 store 消除中的任务。
