use std::{cell::RefCell, collections::HashMap, rc::Rc};

use crate::{metadata::MetaData, RrvmOptimizer};

use llvm::{JumpInstr, LlvmInstrVariant::*, PhiInstr, *};
use rrvm::{
	basicblock::LlvmBasicBlock,
	program::{LlvmFunc, LlvmProgram},
	LlvmNode,
};
use utils::{errors::Result, math::increment, to_label, UseTemp};

use super::{
	entry::{get_func_table, FuncEntry},
	func_list::get_func_list,
	InlineFunction,
};

impl RrvmOptimizer for InlineFunction {
	fn new() -> Self {
		Self {}
	}
	fn apply(
		self,
		program: &mut LlvmProgram,
		_metadata: &mut MetaData,
	) -> Result<bool> {
		let func_list = get_func_list(program);
		if func_list.is_empty() {
			return Ok(false);
		}
		let table = get_func_table(func_list, program);
		program
			.funcs
			.iter_mut()
			.for_each(|func| inline(func, &table, &mut program.temp_mgr));
		Ok(true)
	}
}

fn inline(
	func: &mut LlvmFunc,
	table: &HashMap<String, FuncEntry>,
	mgr: &mut LlvmTempManager,
) {
	let flag = func.cfg.blocks.iter().any(|v| {
		v.borrow()
			.instrs
			.iter()
			.any(|v| v.is_call() && table.contains_key(&v.get_label().name))
	});
	if !flag {
		return;
	}
	let mut blocks = Vec::new();
	let mut edges = Vec::new();
	let mut id2node = HashMap::<i32, LlvmNode>::new();
	let mut phi_map = HashMap::new();
	for block in func.cfg.blocks.iter() {
		let block = &block.borrow();
		let w = block.weight;
		let mut last = LlvmBasicBlock::new(block.id, w);
		last.phi_instrs.clone_from(&block.phi_instrs);
		for instr in block.instrs.iter() {
			match instr.get_variant() {
				CallInstr(instr) if table.contains_key(&instr.func.name) => {
					let entry = table.get(&instr.get_label().name).unwrap();
					let mut new_nodes = Vec::new();
					let mut id_map = HashMap::new();
					let mut temp_map = HashMap::new();
					let mut label_map = HashMap::new();

					macro_rules! convert_target {
						($instr:expr) => {{
							let mut new_instr = $instr.clone();
							if let Some(target) = $instr.get_write() {
								let new_temp = mgr.new_temp(target.var_type, false);
								new_instr.set_target(new_temp.clone());
								temp_map.insert(target, new_temp.into());
							}
							new_instr
						}};
					}

					// get new node generated by inlined function
					for node in entry.nodes.iter() {
						let mut new_node =
							LlvmBasicBlock::new(increment(&mut func.total), w * node.weight);
						id_map.insert(node.id, new_node.id);
						label_map.insert(node.label(), new_node.label());
						for instr in node.phi_instrs.iter() {
							new_node.phi_instrs.push(convert_target!(instr));
						}
						for instr in node.instrs.iter() {
							new_node.instrs.push(convert_target!(instr));
						}
						new_node.jump_instr = node.jump_instr.as_ref().cloned();
						new_nodes.push(new_node);
					}

					// solve parameters
					for (formal, (_, actual)) in
						entry.params.iter().zip(instr.params.iter())
					{
						temp_map.insert(formal.clone(), actual.clone());
					}

					// solve edges in inlined function
					for (u, v) in entry.edges.iter() {
						edges.push((*id_map.get(u).unwrap(), *id_map.get(v).unwrap()));
					}

					// solve the edge from the block before func call
					let func_entry_id = *id_map.get(&0).unwrap();
					edges.push((last.id, func_entry_id));
					last.jump_instr = Some(JumpInstr::new(to_label(func_entry_id)));
					let (last_id, node) = wrap(last);
					id2node.insert(last_id, node.clone());
					blocks.push(node);

					last = LlvmBasicBlock::new(increment(&mut func.total), w);

					// rewrite return instrction & solve return value
					let mut source = Vec::new();
					for mut node in new_nodes {
						node.map_temp(&temp_map);
						node.map_label(&label_map);
						let instr = node.jump_instr.as_ref().unwrap();
						if let RetInstr(instr) = instr.get_variant() {
							if let Some(value) = instr.value.as_ref() {
								source.push((value.clone(), node.label()));
							}
							node.jump_instr = Some(JumpInstr::new(last.label()));
							edges.push((node.id, last.id));
						}
						let (id, node) = wrap(node);
						id2node.insert(id, node.clone());
						blocks.push(node);
					}
					if !entry.var_type.is_void() {
						last.phi_instrs.push(PhiInstr {
							target: instr.target.clone(),
							var_type: instr.var_type,
							source,
						})
					}
				}
				_ => last.instrs.push(instr.clone()),
			}
		}

		// solve the rest of basic block
		for v in block.succ.iter() {
			edges.push((last.id, v.borrow().id))
		}
		last.jump_instr = block.jump_instr.as_ref().cloned();
		phi_map.insert(block.label(), last.label());
		let (id, node) = wrap(last);
		id2node.insert(id, node.clone());
		blocks.push(node);
	}

	// build cfg on new graph
	for block in blocks.iter() {
		block.borrow_mut().clear();
		block.borrow_mut().map_phi_label(&phi_map);
	}
	for (u, v) in edges {
		let x = id2node.get(&u).unwrap();
		let y = id2node.get(&v).unwrap();
		x.borrow_mut().succ.push(y.clone());
		y.borrow_mut().prev.push(x.clone());
	}
	for block in func.cfg.blocks.iter() {
		block.borrow_mut().clear();
	}
	func.cfg.blocks = blocks;
}

fn wrap(block: LlvmBasicBlock) -> (i32, LlvmNode) {
	(block.id, Rc::new(RefCell::new(block)))
}
