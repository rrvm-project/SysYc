## PRE

> 本 pass 需要 GVN 的结果。

部分冗余消除 Partial Redundancy Elimination 会在保证安全的情况下消除部分冗余的计算，并且会尝试进行简单的代码移动。

我们先假设 CFG 中不存在 critical edge，即不存在一条边从 后继不唯一的点 连到 前驱不唯一的点；这一点在我们的项目中是在前端生成中直接确定的，然后控制流优化的 pass 中是在保证这一前提的情况下进行优化的。

在传统的 LCM 和 SSAPRE 中，部分冗余的消除分为两步：插入，将部分冗余转成完全冗余；消除，消除完全冗余的表达式。GVN-PRE 会将

我们将计算一个基本块开头和结尾有哪些可用的表达式。这里可用表达式的含义是可以在当前位置插入：

1. 该表达式在当前位置可以被计算（所有参数都已经被计算出来）
2. 该表达式在当前位置插入是 down safety 的，即插入后不会有某个原本不能访问该表达式计算结果的块能获得这个表达式的结果。

定义开头和结尾可用的表达式集合为 $A_{in}$ 和 $A_{out}$（$A$ 代表 anticipated），那么其上可以定义数据流方程（在这里混淆了表达式和其结果标号；如果两个表达式的标号相同我们结果只保留其中一个，同时某个标号也可以用结果等于该标号的任一表达式表示）：

$$
\begin{aligned}
A_{in}(u) &= A_{out}(dom(u))&(1)\\
A_{out}(u) &= A_{in}(u) \cup tmp(u)&(2)\\
A_{in}(u) &= A_{out}(u) \cup exp(u) - tmp(u)&(3)\\
A_{out}(u) &= \begin{cases}
  \{trans\_phi(e)| e\in A_{in}(succ(u))\} & |succ(u)| = 1 \\
  \{e| e\in A_{in}(v)\ \forall  v \in succ(u)\} & default
\end{cases}&(4)
\end{aligned}
$$

在讨论这些数据流方程之前，先对这里引入的一些额外符号进行定义：
 - $dom(u)$ 表示 $u$ 的直接支配者。
 - $succ(u)$ 表示 $u$ 的后继集合。
 - $tmp(u)$ 表示 $u$ 中定义的新的变量（即指令中等号左边的东西）。
 - $exp(u)$ 表示 $u$ 中包含的所有表达式（即指令中等号右边的东西）。
 - $trans\_phi(e)$ 表示将 $e$ 拿到其所在块前驱的时候，将其中所有用 phi 指令定义的操作数都还原成对应前驱块中的值。

前两个方程是显然的：支配关系保证任意控制流下祖先处可用的表达式在其后代处都可用；当前块内新定义的所有内容之后都是可用的。

后两个方程则讨论了这些集合从后继向前驱更新的情况，其中 $(3)$ 是 $(2)$ 的推广，对于在出口处可用的表达式，如果其不是在当前块内定义的，则其在入口处可用。此外，当前块内的表达式如果没有使用当前块内定义的其他变量，则在入口处也是可用的。

$(4)$ 则讨论了如何跨块从后向前更新数据：
1. 如果当前块的所有后继中某个表达式都是可用的，那么该表达式在当前块结尾处也是可用的。
2. 如果当前块有唯一的后继，那么该后继开头处可用的表达式也可以通过展开 phi 指令得到其在当前块结尾处的值是什么。

经过这样一轮计算后，所有的可用表达式都是 down safety 的，即可以在该位置插入表达式。

对于一个块的 $A_{in}(u)$，我们按 use-def 的拓扑序依次考虑每条指令，如果这条指令经过 phi_trans 后在其某个前驱内已经被计算过，那这条指令就是部分冗余的，我们可以通过其他没被计算过的前驱插入指令，以及当前块前面插入 phi 的方式将这条指令变的完全冗余。我们将按照支配树的 dfs 顺序进行处理，因为新加入的 phi 指令会改变当前支配树子树内指令的操作数，按 dfs 序的话可以一边插入 phi 指令一边修正操作数。

特别的，在前驱块中插入的指令一定会新增在 $A_{in}(u)$ 中，因为该指令如果不冗余则必然不在 $tmp(u)$ 里，于是根据定义会在 $A_{in}(u)$ 之中。这条新加入 $A_{in}$ 的语句理应也按照上一段中的方法尝试寻找和消除部分冗余，但是这个前驱点很可能已经被处理过了。为了处理这种情况，上一段的插入应当反复进行。

最后再遍历一次支配树进行完全冗余消除，这个 pass 就结束了。